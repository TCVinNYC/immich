/* tslint:disable */
/* eslint-disable */
/**
 * Immich
 * Immich API
 *
 * The version of the OpenAPI document: 1.17.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import './configuration';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from './base';
/**
 *
 * @export
 * @enum {string}
 */
export const AssetTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Audio: 'AUDIO',
    Other: 'OTHER'
};
/**
 *
 * @export
 * @enum {string}
 */
export const DeleteAssetStatus = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
};
/**
 *
 * @export
 * @enum {string}
 */
export const DeviceTypeEnum = {
    Ios: 'IOS',
    Android: 'ANDROID',
    Web: 'WEB'
};
/**
 *
 * @export
 * @enum {string}
 */
export const ThumbnailFormat = {
    Jpeg: 'JPEG',
    Webp: 'WEBP'
};
/**
 *
 * @export
 * @enum {string}
 */
export const TimeGroupEnum = {
    Day: 'day',
    Month: 'month'
};
/**
 * AlbumApi - axios parameter creator
 * @export
 */
export const AlbumApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} albumId
         * @param {AddAssetsDto} addAssetsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum: async (albumId, addAssetsDto, options = {}) => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'albumId', albumId);
            // verify required parameter 'addAssetsDto' is not null or undefined
            assertParamExists('addAssetsToAlbum', 'addAssetsDto', addAssetsDto);
            const localVarPath = `/album/{albumId}/assets`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addAssetsDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} albumId
         * @param {AddUsersDto} addUsersDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum: async (albumId, addUsersDto, options = {}) => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('addUsersToAlbum', 'albumId', albumId);
            // verify required parameter 'addUsersDto' is not null or undefined
            assertParamExists('addUsersToAlbum', 'addUsersDto', addUsersDto);
            const localVarPath = `/album/{albumId}/users`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addUsersDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {CreateAlbumDto} createAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum: async (createAlbumDto, options = {}) => {
            // verify required parameter 'createAlbumDto' is not null or undefined
            assertParamExists('createAlbum', 'createAlbumDto', createAlbumDto);
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createAlbumDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} albumId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum: async (albumId, options = {}) => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('deleteAlbum', 'albumId', albumId);
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} albumId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo: async (albumId, options = {}) => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('getAlbumInfo', 'albumId', albumId);
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} [shared]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums: async (shared, options = {}) => {
            const localVarPath = `/album`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (shared !== undefined) {
                localVarQueryParameter['shared'] = shared;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} albumId
         * @param {RemoveAssetsDto} removeAssetsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum: async (albumId, removeAssetsDto, options = {}) => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'albumId', albumId);
            // verify required parameter 'removeAssetsDto' is not null or undefined
            assertParamExists('removeAssetFromAlbum', 'removeAssetsDto', removeAssetsDto);
            const localVarPath = `/album/{albumId}/assets`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(removeAssetsDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} albumId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum: async (albumId, userId, options = {}) => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'albumId', albumId);
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromAlbum', 'userId', userId);
            const localVarPath = `/album/{albumId}/user/{userId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} albumId
         * @param {UpdateAlbumDto} updateAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo: async (albumId, updateAlbumDto, options = {}) => {
            // verify required parameter 'albumId' is not null or undefined
            assertParamExists('updateAlbumInfo', 'albumId', albumId);
            // verify required parameter 'updateAlbumDto' is not null or undefined
            assertParamExists('updateAlbumInfo', 'updateAlbumDto', updateAlbumDto);
            const localVarPath = `/album/{albumId}`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateAlbumDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AlbumApi - functional programming interface
 * @export
 */
export const AlbumApiFp = function (configuration) {
    const localVarAxiosParamCreator = AlbumApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {string} albumId
         * @param {AddAssetsDto} addAssetsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAssetsToAlbum(albumId, addAssetsDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAssetsToAlbum(albumId, addAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} albumId
         * @param {AddUsersDto} addUsersDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUsersToAlbum(albumId, addUsersDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToAlbum(albumId, addUsersDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {CreateAlbumDto} createAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbum(createAlbumDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlbum(createAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} albumId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlbum(albumId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlbum(albumId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} albumId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumInfo(albumId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlbumInfo(albumId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {boolean} [shared]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAlbums(shared, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAlbums(shared, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} albumId
         * @param {RemoveAssetsDto} removeAssetsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAssetFromAlbum(albumId, removeAssetsDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAssetFromAlbum(albumId, removeAssetsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} albumId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromAlbum(albumId, userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromAlbum(albumId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} albumId
         * @param {UpdateAlbumDto} updateAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAlbumInfo(albumId, updateAlbumDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAlbumInfo(albumId, updateAlbumDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AlbumApi - factory interface
 * @export
 */
export const AlbumApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AlbumApiFp(configuration);
    return {
        /**
         *
         * @param {string} albumId
         * @param {AddAssetsDto} addAssetsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetsToAlbum(albumId, addAssetsDto, options) {
            return localVarFp.addAssetsToAlbum(albumId, addAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} albumId
         * @param {AddUsersDto} addUsersDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUsersToAlbum(albumId, addUsersDto, options) {
            return localVarFp.addUsersToAlbum(albumId, addUsersDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CreateAlbumDto} createAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(createAlbumDto, options) {
            return localVarFp.createAlbum(createAlbumDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} albumId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlbum(albumId, options) {
            return localVarFp.deleteAlbum(albumId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} albumId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumInfo(albumId, options) {
            return localVarFp.getAlbumInfo(albumId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {boolean} [shared]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlbums(shared, options) {
            return localVarFp.getAllAlbums(shared, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} albumId
         * @param {RemoveAssetsDto} removeAssetsDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAssetFromAlbum(albumId, removeAssetsDto, options) {
            return localVarFp.removeAssetFromAlbum(albumId, removeAssetsDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} albumId
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromAlbum(albumId, userId, options) {
            return localVarFp.removeUserFromAlbum(albumId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} albumId
         * @param {UpdateAlbumDto} updateAlbumDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlbumInfo(albumId, updateAlbumDto, options) {
            return localVarFp.updateAlbumInfo(albumId, updateAlbumDto, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AlbumApi - object-oriented interface
 * @export
 * @class AlbumApi
 * @extends {BaseAPI}
 */
export class AlbumApi extends BaseAPI {
    /**
     *
     * @param {string} albumId
     * @param {AddAssetsDto} addAssetsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    addAssetsToAlbum(albumId, addAssetsDto, options) {
        return AlbumApiFp(this.configuration).addAssetsToAlbum(albumId, addAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} albumId
     * @param {AddUsersDto} addUsersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    addUsersToAlbum(albumId, addUsersDto, options) {
        return AlbumApiFp(this.configuration).addUsersToAlbum(albumId, addUsersDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CreateAlbumDto} createAlbumDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    createAlbum(createAlbumDto, options) {
        return AlbumApiFp(this.configuration).createAlbum(createAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} albumId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    deleteAlbum(albumId, options) {
        return AlbumApiFp(this.configuration).deleteAlbum(albumId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} albumId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    getAlbumInfo(albumId, options) {
        return AlbumApiFp(this.configuration).getAlbumInfo(albumId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {boolean} [shared]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    getAllAlbums(shared, options) {
        return AlbumApiFp(this.configuration).getAllAlbums(shared, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} albumId
     * @param {RemoveAssetsDto} removeAssetsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    removeAssetFromAlbum(albumId, removeAssetsDto, options) {
        return AlbumApiFp(this.configuration).removeAssetFromAlbum(albumId, removeAssetsDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} albumId
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    removeUserFromAlbum(albumId, userId, options) {
        return AlbumApiFp(this.configuration).removeUserFromAlbum(albumId, userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} albumId
     * @param {UpdateAlbumDto} updateAlbumDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumApi
     */
    updateAlbumInfo(albumId, updateAlbumDto, options) {
        return AlbumApiFp(this.configuration).updateAlbumInfo(albumId, updateAlbumDto, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @summary
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset: async (checkDuplicateAssetDto, options = {}) => {
            // verify required parameter 'checkDuplicateAssetDto' is not null or undefined
            assertParamExists('checkDuplicateAsset', 'checkDuplicateAssetDto', checkDuplicateAssetDto);
            const localVarPath = `/asset/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(checkDuplicateAssetDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {DeleteAssetDto} deleteAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset: async (deleteAssetDto, options = {}) => {
            // verify required parameter 'deleteAssetDto' is not null or undefined
            assertParamExists('deleteAsset', 'deleteAssetDto', deleteAssetDto);
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAssetDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} aid
         * @param {string} did
         * @param {boolean} [isThumb]
         * @param {boolean} [isWeb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (aid, did, isThumb, isWeb, options = {}) => {
            // verify required parameter 'aid' is not null or undefined
            assertParamExists('downloadFile', 'aid', aid);
            // verify required parameter 'did' is not null or undefined
            assertParamExists('downloadFile', 'did', did);
            const localVarPath = `/asset/download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (aid !== undefined) {
                localVarQueryParameter['aid'] = aid;
            }
            if (did !== undefined) {
                localVarQueryParameter['did'] = did;
            }
            if (isThumb !== undefined) {
                localVarQueryParameter['isThumb'] = isThumb;
            }
            if (isWeb !== undefined) {
                localVarQueryParameter['isWeb'] = isWeb;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all AssetEntity belong to the user
         * @summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets: async (options = {}) => {
            const localVarPath = `/asset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single asset\'s information
         * @summary
         * @param {string} assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById: async (assetId, options = {}) => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetById', 'assetId', assetId);
            const localVarPath = `/asset/assetById/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {GetAssetCountByTimeGroupDto} getAssetCountByTimeGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByTimeGroup: async (getAssetCountByTimeGroupDto, options = {}) => {
            // verify required parameter 'getAssetCountByTimeGroupDto' is not null or undefined
            assertParamExists('getAssetCountByTimeGroup', 'getAssetCountByTimeGroupDto', getAssetCountByTimeGroupDto);
            const localVarPath = `/asset/count-by-date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(getAssetCountByTimeGroupDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms: async (options = {}) => {
            const localVarPath = `/asset/search-terms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} assetId
         * @param {ThumbnailFormat} [format]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail: async (assetId, format, options = {}) => {
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('getAssetThumbnail', 'assetId', assetId);
            const localVarPath = `/asset/thumbnail/{assetId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations: async (options = {}) => {
            const localVarPath = `/asset/curated-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects: async (options = {}) => {
            const localVarPath = `/asset/curated-objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @summary
         * @param {string} deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId: async (deviceId, options = {}) => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('getUserAssetsByDeviceId', 'deviceId', deviceId);
            const localVarPath = `/asset/{deviceId}`
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {SearchAssetDto} searchAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset: async (searchAssetDto, options = {}) => {
            // verify required parameter 'searchAssetDto' is not null or undefined
            assertParamExists('searchAsset', 'searchAssetDto', searchAssetDto);
            const localVarPath = `/asset/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(searchAssetDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} aid
         * @param {string} did
         * @param {boolean} [isThumb]
         * @param {boolean} [isWeb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile: async (aid, did, isThumb, isWeb, options = {}) => {
            // verify required parameter 'aid' is not null or undefined
            assertParamExists('serveFile', 'aid', aid);
            // verify required parameter 'did' is not null or undefined
            assertParamExists('serveFile', 'did', did);
            const localVarPath = `/asset/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (aid !== undefined) {
                localVarQueryParameter['aid'] = aid;
            }
            if (did !== undefined) {
                localVarQueryParameter['did'] = did;
            }
            if (isThumb !== undefined) {
                localVarQueryParameter['isThumb'] = isThumb;
            }
            if (isWeb !== undefined) {
                localVarQueryParameter['isWeb'] = isWeb;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {any} assetData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (assetData, options = {}) => {
            // verify required parameter 'assetData' is not null or undefined
            assertParamExists('uploadFile', 'assetData', assetData);
            const localVarPath = `/asset/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (assetData !== undefined) {
                localVarFormParams.append('assetData', assetData);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function (configuration) {
    const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration);
    return {
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @summary
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDuplicateAsset(checkDuplicateAssetDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDuplicateAsset(checkDuplicateAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {DeleteAssetDto} deleteAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAsset(deleteAssetDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAsset(deleteAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} aid
         * @param {string} did
         * @param {boolean} [isThumb]
         * @param {boolean} [isWeb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(aid, did, isThumb, isWeb, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(aid, did, isThumb, isWeb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all AssetEntity belong to the user
         * @summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssets(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a single asset\'s information
         * @summary
         * @param {string} assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetById(assetId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetById(assetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {GetAssetCountByTimeGroupDto} getAssetCountByTimeGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetCountByTimeGroup(getAssetCountByTimeGroupDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetCountByTimeGroup(getAssetCountByTimeGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetSearchTerms(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetSearchTerms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} assetId
         * @param {ThumbnailFormat} [format]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetThumbnail(assetId, format, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetThumbnail(assetId, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedLocations(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedLocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCuratedObjects(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCuratedObjects(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @summary
         * @param {string} deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAssetsByDeviceId(deviceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssetsByDeviceId(deviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {SearchAssetDto} searchAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAsset(searchAssetDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAsset(searchAssetDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} aid
         * @param {string} did
         * @param {boolean} [isThumb]
         * @param {boolean} [isWeb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveFile(aid, did, isThumb, isWeb, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveFile(aid, did, isThumb, isWeb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {any} assetData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(assetData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(assetData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AssetApiFp(configuration);
    return {
        /**
         * Check duplicated asset before uploading - for Web upload used
         * @summary
         * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDuplicateAsset(checkDuplicateAssetDto, options) {
            return localVarFp.checkDuplicateAsset(checkDuplicateAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {DeleteAssetDto} deleteAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(deleteAssetDto, options) {
            return localVarFp.deleteAsset(deleteAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} aid
         * @param {string} did
         * @param {boolean} [isThumb]
         * @param {boolean} [isWeb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(aid, did, isThumb, isWeb, options) {
            return localVarFp.downloadFile(aid, did, isThumb, isWeb, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all AssetEntity belong to the user
         * @summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssets(options) {
            return localVarFp.getAllAssets(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single asset\'s information
         * @summary
         * @param {string} assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetById(assetId, options) {
            return localVarFp.getAssetById(assetId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {GetAssetCountByTimeGroupDto} getAssetCountByTimeGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetCountByTimeGroup(getAssetCountByTimeGroupDto, options) {
            return localVarFp.getAssetCountByTimeGroup(getAssetCountByTimeGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetSearchTerms(options) {
            return localVarFp.getAssetSearchTerms(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} assetId
         * @param {ThumbnailFormat} [format]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetThumbnail(assetId, format, options) {
            return localVarFp.getAssetThumbnail(assetId, format, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedLocations(options) {
            return localVarFp.getCuratedLocations(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCuratedObjects(options) {
            return localVarFp.getCuratedObjects(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all asset of a device that are in the database, ID only.
         * @summary
         * @param {string} deviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetsByDeviceId(deviceId, options) {
            return localVarFp.getUserAssetsByDeviceId(deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SearchAssetDto} searchAssetDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAsset(searchAssetDto, options) {
            return localVarFp.searchAsset(searchAssetDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} aid
         * @param {string} did
         * @param {boolean} [isThumb]
         * @param {boolean} [isWeb]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFile(aid, did, isThumb, isWeb, options) {
            return localVarFp.serveFile(aid, did, isThumb, isWeb, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {any} assetData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(assetData, options) {
            return localVarFp.uploadFile(assetData, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * Check duplicated asset before uploading - for Web upload used
     * @summary
     * @param {CheckDuplicateAssetDto} checkDuplicateAssetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    checkDuplicateAsset(checkDuplicateAssetDto, options) {
        return AssetApiFp(this.configuration).checkDuplicateAsset(checkDuplicateAssetDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {DeleteAssetDto} deleteAssetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    deleteAsset(deleteAssetDto, options) {
        return AssetApiFp(this.configuration).deleteAsset(deleteAssetDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} aid
     * @param {string} did
     * @param {boolean} [isThumb]
     * @param {boolean} [isWeb]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    downloadFile(aid, did, isThumb, isWeb, options) {
        return AssetApiFp(this.configuration).downloadFile(aid, did, isThumb, isWeb, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all AssetEntity belong to the user
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    getAllAssets(options) {
        return AssetApiFp(this.configuration).getAllAssets(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single asset\'s information
     * @summary
     * @param {string} assetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    getAssetById(assetId, options) {
        return AssetApiFp(this.configuration).getAssetById(assetId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {GetAssetCountByTimeGroupDto} getAssetCountByTimeGroupDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    getAssetCountByTimeGroup(getAssetCountByTimeGroupDto, options) {
        return AssetApiFp(this.configuration).getAssetCountByTimeGroup(getAssetCountByTimeGroupDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    getAssetSearchTerms(options) {
        return AssetApiFp(this.configuration).getAssetSearchTerms(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} assetId
     * @param {ThumbnailFormat} [format]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    getAssetThumbnail(assetId, format, options) {
        return AssetApiFp(this.configuration).getAssetThumbnail(assetId, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    getCuratedLocations(options) {
        return AssetApiFp(this.configuration).getCuratedLocations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    getCuratedObjects(options) {
        return AssetApiFp(this.configuration).getCuratedObjects(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all asset of a device that are in the database, ID only.
     * @summary
     * @param {string} deviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    getUserAssetsByDeviceId(deviceId, options) {
        return AssetApiFp(this.configuration).getUserAssetsByDeviceId(deviceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SearchAssetDto} searchAssetDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    searchAsset(searchAssetDto, options) {
        return AssetApiFp(this.configuration).searchAsset(searchAssetDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} aid
     * @param {string} did
     * @param {boolean} [isThumb]
     * @param {boolean} [isWeb]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    serveFile(aid, did, isThumb, isWeb, options) {
        return AssetApiFp(this.configuration).serveFile(aid, did, isThumb, isWeb, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {any} assetData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    uploadFile(assetData, options) {
        return AssetApiFp(this.configuration).uploadFile(assetData, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {SignUpDto} signUpDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp: async (signUpDto, options = {}) => {
            // verify required parameter 'signUpDto' is not null or undefined
            assertParamExists('adminSignUp', 'signUpDto', signUpDto);
            const localVarPath = `/auth/admin-sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(signUpDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {LoginCredentialDto} loginCredentialDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginCredentialDto, options = {}) => {
            // verify required parameter 'loginCredentialDto' is not null or undefined
            assertParamExists('login', 'loginCredentialDto', loginCredentialDto);
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(loginCredentialDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options = {}) => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken: async (options = {}) => {
            const localVarPath = `/auth/validateToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {SignUpDto} signUpDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSignUp(signUpDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSignUp(signUpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {LoginCredentialDto} loginCredentialDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginCredentialDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAccessToken(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAccessToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AuthenticationApiFp(configuration);
    return {
        /**
         *
         * @param {SignUpDto} signUpDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignUp(signUpDto, options) {
            return localVarFp.adminSignUp(signUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {LoginCredentialDto} loginCredentialDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginCredentialDto, options) {
            return localVarFp.login(loginCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options) {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAccessToken(options) {
            return localVarFp.validateAccessToken(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     *
     * @param {SignUpDto} signUpDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    adminSignUp(signUpDto, options) {
        return AuthenticationApiFp(this.configuration).adminSignUp(signUpDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {LoginCredentialDto} loginCredentialDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    login(loginCredentialDto, options) {
        return AuthenticationApiFp(this.configuration).login(loginCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logout(options) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    validateAccessToken(options) {
        return AuthenticationApiFp(this.configuration).validateAccessToken(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DeviceInfoApi - axios parameter creator
 * @export
 */
export const DeviceInfoApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CreateDeviceInfoDto} createDeviceInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceInfo: async (createDeviceInfoDto, options = {}) => {
            // verify required parameter 'createDeviceInfoDto' is not null or undefined
            assertParamExists('createDeviceInfo', 'createDeviceInfoDto', createDeviceInfoDto);
            const localVarPath = `/device-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createDeviceInfoDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpdateDeviceInfoDto} updateDeviceInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceInfo: async (updateDeviceInfoDto, options = {}) => {
            // verify required parameter 'updateDeviceInfoDto' is not null or undefined
            assertParamExists('updateDeviceInfo', 'updateDeviceInfoDto', updateDeviceInfoDto);
            const localVarPath = `/device-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateDeviceInfoDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DeviceInfoApi - functional programming interface
 * @export
 */
export const DeviceInfoApiFp = function (configuration) {
    const localVarAxiosParamCreator = DeviceInfoApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {CreateDeviceInfoDto} createDeviceInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeviceInfo(createDeviceInfoDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeviceInfo(createDeviceInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {UpdateDeviceInfoDto} updateDeviceInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceInfo(updateDeviceInfoDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceInfo(updateDeviceInfoDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DeviceInfoApi - factory interface
 * @export
 */
export const DeviceInfoApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DeviceInfoApiFp(configuration);
    return {
        /**
         *
         * @param {CreateDeviceInfoDto} createDeviceInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceInfo(createDeviceInfoDto, options) {
            return localVarFp.createDeviceInfo(createDeviceInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateDeviceInfoDto} updateDeviceInfoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceInfo(updateDeviceInfoDto, options) {
            return localVarFp.updateDeviceInfo(updateDeviceInfoDto, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DeviceInfoApi - object-oriented interface
 * @export
 * @class DeviceInfoApi
 * @extends {BaseAPI}
 */
export class DeviceInfoApi extends BaseAPI {
    /**
     *
     * @param {CreateDeviceInfoDto} createDeviceInfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    createDeviceInfo(createDeviceInfoDto, options) {
        return DeviceInfoApiFp(this.configuration).createDeviceInfo(createDeviceInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UpdateDeviceInfoDto} updateDeviceInfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    updateDeviceInfo(updateDeviceInfoDto, options) {
        return DeviceInfoApiFp(this.configuration).updateDeviceInfo(updateDeviceInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ServerInfoApi - axios parameter creator
 * @export
 */
export const ServerInfoApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options = {}) => {
            const localVarPath = `/server-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion: async (options = {}) => {
            const localVarPath = `/server-info/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer: async (options = {}) => {
            const localVarPath = `/server-info/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ServerInfoApi - functional programming interface
 * @export
 */
export const ServerInfoApiFp = function (configuration) {
    const localVarAxiosParamCreator = ServerInfoApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerVersion(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingServer(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingServer(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ServerInfoApi - factory interface
 * @export
 */
export const ServerInfoApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ServerInfoApiFp(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options) {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerVersion(options) {
            return localVarFp.getServerVersion(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingServer(options) {
            return localVarFp.pingServer(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ServerInfoApi - object-oriented interface
 * @export
 * @class ServerInfoApi
 * @extends {BaseAPI}
 */
export class ServerInfoApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    getServerInfo(options) {
        return ServerInfoApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    getServerVersion(options) {
        return ServerInfoApiFp(this.configuration).getServerVersion(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    pingServer(options) {
        return ServerInfoApiFp(this.configuration).pingServer(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {any} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage: async (file, options = {}) => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createProfileImage', 'file', file);
            const localVarPath = `/user/profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {CreateUserDto} createUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserDto, options = {}) => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('createUser', 'createUserDto', createUserDto);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} isAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (isAll, options = {}) => {
            // verify required parameter 'isAll' is not null or undefined
            assertParamExists('getAllUsers', 'isAll', isAll);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (isAll !== undefined) {
                localVarQueryParameter['isAll'] = isAll;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo: async (options = {}) => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProfileImage', 'userId', userId);
            const localVarPath = `/user/profile-image/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId);
            const localVarPath = `/user/info/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount: async (options = {}) => {
            const localVarPath = `/user/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {UpdateUserDto} updateUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserDto, options = {}) => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('updateUser', 'updateUserDto', updateUserDto);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {any} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileImage(file, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileImage(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {CreateUserDto} createUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {boolean} isAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(isAll, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(isAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUserInfo(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileImage(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileImage(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCount(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @param {UpdateUserDto} updateUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserApiFp(configuration);
    return {
        /**
         *
         * @param {any} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileImage(file, options) {
            return localVarFp.createProfileImage(file, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {CreateUserDto} createUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserDto, options) {
            return localVarFp.createUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {boolean} isAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(isAll, options) {
            return localVarFp.getAllUsers(isAll, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUserInfo(options) {
            return localVarFp.getMyUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileImage(userId, options) {
            return localVarFp.getProfileImage(userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId, options) {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCount(options) {
            return localVarFp.getUserCount(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UpdateUserDto} updateUserDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserDto, options) {
            return localVarFp.updateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createProfileImage(file, options) {
        return UserApiFp(this.configuration).createProfileImage(file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {CreateUserDto} createUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(createUserDto, options) {
        return UserApiFp(this.configuration).createUser(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {boolean} isAll
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getAllUsers(isAll, options) {
        return UserApiFp(this.configuration).getAllUsers(isAll, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getMyUserInfo(options) {
        return UserApiFp(this.configuration).getMyUserInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getProfileImage(userId, options) {
        return UserApiFp(this.configuration).getProfileImage(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserById(userId, options) {
        return UserApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserCount(options) {
        return UserApiFp(this.configuration).getUserCount(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UpdateUserDto} updateUserDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(updateUserDto, options) {
        return UserApiFp(this.configuration).updateUser(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}
//# sourceMappingURL=api.js.map